import { Handler } from 'aws-lambda';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { KinesisClient, PutRecordCommand } from '@aws-sdk/client-kinesis';
import axios from 'axios';

interface CVEItem {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        cvssData: {
          version: string;
          vectorString: string;
          baseScore: number;
          baseSeverity: string;
        };
      }>;
      cvssMetricV2?: Array<{
        cvssData: {
          version: string;
          vectorString: string;
          baseScore: number;
          baseSeverity: string;
        };
      }>;
    };
    weaknesses?: Array<{
      description: Array<{
        lang: string;
        value: string;
      }>;
    }>;
    configurations?: Array<{
      nodes: Array<{
        operator: string;
        cpeMatch: Array<{
          vulnerable: boolean;
          criteria: string;
          versionStartIncluding?: string;
          versionEndExcluding?: string;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
      tags?: string[];
    }>;
  };
}

interface ThreatIntelDocument {
  id: string;
  source: 'CVE';
  title: string;
  content: string;
  metadata: {
    confidence: number;
    tlp: 'WHITE' | 'GREEN' | 'AMBER' | 'RED';
    tags: string[];
    created: Date;
    updated: Date;
    cvss_score?: number;
    severity?: string;
    status: string;
  };
  vulnerabilities: {
    cve_id: string;
    cvss_score?: number;
    severity?: string;
    cpe_matches: string[];
    weaknesses: string[];
  }[];
}

const s3Client = new S3Client({});
const kinesisClient = new KinesisClient({});

export const handler: Handler = async (event, context) => {
  console.log('CVE Ingester started', JSON.stringify(event));

  try {
    // Determine date range for CVE fetch
    const endDate = new Date();
    const startDate = new Date(endDate.getTime() - (24 * 60 * 60 * 1000)); // Last 24 hours
    
    // Fetch recent CVEs
    const cveItems = await fetchRecentCVEs(startDate, endDate);
    console.log(`Fetched ${cveItems.length} CVE items`);

    // Process each CVE
    const processedDocuments: ThreatIntelDocument[] = [];
    
    for (const cveItem of cveItems) {
      try {
        const document = await processCVEItem(cveItem);
        processedDocuments.push(document);
        
        // Store document in S3
        await storeDocument(document);
        
        // Send to Kinesis for real-time processing
        await sendToKinesis(document);
        
      } catch (error) {
        console.error(`Error processing CVE ${cveItem.cve.id}:`, error);
      }
    }

    console.log(`Successfully processed ${processedDocuments.length} CVE items`);
    
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'CVE ingestion completed',
        processed: processedDocuments.length,
        documents: processedDocuments.map(d => ({ id: d.id, title: d.title }))
      })
    };

  } catch (error) {
    console.error('CVE ingestion failed:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'CVE ingestion failed', details: error.message })
    };
  }
};

async function fetchRecentCVEs(startDate: Date, endDate: Date): Promise<CVEItem[]> {
  try {
    const baseUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
    const startParam = startDate.toISOString().split('T')[0];
    const endParam = endDate.toISOString().split('T')[0];
    
    console.log(`Fetching CVEs from ${startParam} to ${endParam}`);
    
    const response = await axios.get(baseUrl, {
      params: {
        pubStartDate: startParam,
        pubEndDate: endParam,
        resultsPerPage: 2000,
        startIndex: 0
      },
      timeout: 60000,
      headers: {
        'User-Agent': 'THRAG-CVE-Ingester/1.0'
      }
    });

    return response.data.vulnerabilities || [];
  } catch (error) {
    console.error('Error fetching CVEs:', error);
    
    // If API fails, return empty array to prevent complete failure
    if (error.response?.status === 429) {
      console.log('Rate limited by NVD API, will retry later');
      return [];
    }
    
    throw new Error(`Failed to fetch CVEs: ${error.message}`);
  }
}

async function processCVEItem(cveItem: CVEItem): Promise<ThreatIntelDocument> {
  const cve = cveItem.cve;
  
  // Extract CVSS information
  const cvssV31 = cve.metrics?.cvssMetricV31?.[0]?.cvssData;
  const cvssV2 = cve.metrics?.cvssMetricV2?.[0]?.cvssData;
  const cvssScore = cvssV31?.baseScore || cvssV2?.baseScore;
  const severity = cvssV31?.baseSeverity || cvssV2?.baseSeverity || 'UNKNOWN';
  
  // Extract description
  const description = cve.descriptions?.find(d => d.lang === 'en')?.value || 'No description available';
  
  // Extract weaknesses (CWE)
  const weaknesses = cve.weaknesses?.flatMap(w => 
    w.description.filter(d => d.lang === 'en').map(d => d.value)
  ) || [];
  
  // Extract CPE matches
  const cpeMatches = cve.configurations?.flatMap(config =>
    config.nodes.flatMap(node =>
      node.cpeMatch.map(match => match.criteria)
    )
  ) || [];
  
  // Extract references
  const references = cve.references?.map(ref => ref.url) || [];
  
  // Generate tags based on severity and characteristics
  const tags = generateCVETags(severity, weaknesses, cpeMatches);
  
  // Generate content for RAG
  const content = generateCVEContent(cve, description, cvssScore, severity, weaknesses, cpeMatches, references);
  
  // Calculate confidence based on CVSS score and data completeness
  const confidence = calculateCVEConfidence(cvssScore, weaknesses.length, cpeMatches.length);

  const document: ThreatIntelDocument = {
    id: `cve-${cve.id}-${Date.now()}`,
    source: 'CVE',
    title: `${cve.id}: ${description.substring(0, 100)}...`,
    content,
    metadata: {
      confidence,
      tlp: 'WHITE', // CVE data is public
      tags,
      created: new Date(cve.published),
      updated: new Date(cve.lastModified),
      cvss_score: cvssScore,
      severity,
      status: cve.vulnStatus
    },
    vulnerabilities: [{
      cve_id: cve.id,
      cvss_score: cvssScore,
      severity,
      cpe_matches: cpeMatches,
      weaknesses
    }]
  };

  return document;
}

function generateCVETags(severity: string, weaknesses: string[], cpeMatches: string[]): string[] {
  const tags = ['vulnerability', 'cve'];
  
  // Add severity tag
  if (severity && severity !== 'UNKNOWN') {
    tags.push(`severity-${severity.toLowerCase()}`);
  }
  
  // Add weakness tags
  weaknesses.forEach(weakness => {
    if (weakness.includes('CWE-')) {
      tags.push(weakness.toLowerCase());
    }
  });
  
  // Add technology tags based on CPE matches
  cpeMatches.forEach(cpe => {
    const parts = cpe.split(':');
    if (parts.length >= 4) {
      const vendor = parts[3];
      const product = parts[4];
      if (vendor && vendor !== '*') tags.push(`vendor-${vendor}`);
      if (product && product !== '*') tags.push(`product-${product}`);
    }
  });
  
  return [...new Set(tags)]; // Remove duplicates
}

function generateCVEContent(
  cve: any,
  description: string,
  cvssScore?: number,
  severity?: string,
  weaknesses?: string[],
  cpeMatches?: string[],
  references?: string[]
): string {
  const sections = [
    `CVE: ${cve.id}`,
    `Published: ${new Date(cve.published).toISOString()}`,
    `Last Modified: ${new Date(cve.lastModified).toISOString()}`,
    `Status: ${cve.vulnStatus}`,
    '',
    'CVSS Information:',
    cvssScore ? `- CVSS Score: ${cvssScore}` : '- CVSS Score: Not available',
    severity ? `- Severity: ${severity}` : '- Severity: Not available',
    '',
    'Description:',
    description,
    '',
    'Weaknesses (CWE):',
    ...(weaknesses?.length ? weaknesses.map(w => `- ${w}`) : ['- No weaknesses identified']),
    '',
    'Affected Products (CPE):',
    ...(cpeMatches?.length ? cpeMatches.slice(0, 10).map(cpe => `- ${cpe}`) : ['- No specific products identified']),
    ...(cpeMatches?.length > 10 ? [`- ... and ${cpeMatches.length - 10} more`] : []),
    '',
    'References:',
    ...(references?.length ? references.slice(0, 5).map(ref => `- ${ref}`) : ['- No references available']),
    '',
    'Risk Assessment:',
    generateRiskAssessment(cvssScore, severity, weaknesses),
    '',
    'Recommended Actions:',
    generateRecommendations(cvssScore, severity)
  ];

  return sections.join('\n');
}

function generateRiskAssessment(cvssScore?: number, severity?: string, weaknesses?: string[]): string {
  if (!cvssScore) {
    return 'Risk assessment pending - CVSS score not available.';
  }
  
  const riskLevel = cvssScore >= 9.0 ? 'CRITICAL' :
                   cvssScore >= 7.0 ? 'HIGH' :
                   cvssScore >= 4.0 ? 'MEDIUM' : 'LOW';
  
  const hasRemoteExploit = weaknesses?.some(w => 
    w.includes('Remote Code Execution') || 
    w.includes('Buffer Overflow') ||
    w.includes('Injection')
  );
  
  let assessment = `This vulnerability has a ${riskLevel} risk level with CVSS score ${cvssScore}.`;
  
  if (hasRemoteExploit) {
    assessment += ' The vulnerability may allow remote code execution, significantly increasing the risk.';
  }
  
  if (cvssScore >= 7.0) {
    assessment += ' Immediate attention and patching is recommended.';
  }
  
  return assessment;
}

function generateRecommendations(cvssScore?: number, severity?: string): string {
  if (!cvssScore) {
    return '- Monitor for CVSS score updates and vendor patches\n- Assess organizational exposure to affected products';
  }
  
  if (cvssScore >= 9.0) {
    return '- URGENT: Apply patches immediately\n- Consider emergency change procedures\n- Implement compensating controls if patches unavailable\n- Monitor for active exploitation';
  } else if (cvssScore >= 7.0) {
    return '- Apply patches within 72 hours\n- Prioritize internet-facing systems\n- Implement network segmentation if possible\n- Monitor for exploitation attempts';
  } else if (cvssScore >= 4.0) {
    return '- Apply patches during next maintenance window\n- Assess organizational exposure\n- Consider risk acceptance if patching is complex';
  } else {
    return '- Apply patches as part of regular maintenance\n- Document risk acceptance decision\n- Monitor for changes in threat landscape';
  }
}

function calculateCVEConfidence(cvssScore?: number, weaknessCount?: number, cpeCount?: number): number {
  let confidence = 0.7; // Base confidence for CVE data
  
  // Adjust based on CVSS score availability
  if (cvssScore) {
    confidence += 0.2;
  }
  
  // Adjust based on weakness information
  if (weaknessCount && weaknessCount > 0) {
    confidence += 0.05;
  }
  
  // Adjust based on CPE information
  if (cpeCount && cpeCount > 0) {
    confidence += 0.05;
  }
  
  return Math.min(confidence, 1.0);
}

async function storeDocument(document: ThreatIntelDocument): Promise<void> {
  const bucketName = process.env.THREAT_INTEL_BUCKET;
  if (!bucketName) {
    throw new Error('THREAT_INTEL_BUCKET environment variable not set');
  }

  const key = `cve/${document.id}.json`;
  
  const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: JSON.stringify(document, null, 2),
    ContentType: 'application/json',
    Metadata: {
      source: document.source,
      confidence: document.metadata.confidence.toString(),
      cvss_score: document.metadata.cvss_score?.toString() || 'unknown',
      severity: document.metadata.severity || 'unknown'
    }
  });

  await s3Client.send(command);
  console.log(`Stored document ${document.id} in S3: ${key}`);
}

async function sendToKinesis(document: ThreatIntelDocument): Promise<void> {
  const streamName = process.env.THREAT_INTEL_STREAM;
  if (!streamName) {
    console.log('THREAT_INTEL_STREAM not configured, skipping Kinesis');
    return;
  }

  const record = {
    eventType: 'threat-intelligence-update',
    source: 'cve-ingester',
    timestamp: new Date().toISOString(),
    data: {
      documentId: document.id,
      source: document.source,
      title: document.title,
      confidence: document.metadata.confidence,
      cvssScore: document.metadata.cvss_score,
      severity: document.metadata.severity,
      cveId: document.vulnerabilities[0]?.cve_id
    }
  };

  const command = new PutRecordCommand({
    StreamName: streamName,
    Data: Buffer.from(JSON.stringify(record)),
    PartitionKey: document.id
  });

  await kinesisClient.send(command);
  console.log(`Sent document ${document.id} to Kinesis stream ${streamName}`);
}